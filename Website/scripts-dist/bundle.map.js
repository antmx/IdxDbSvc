{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "scripts-dist/CreateDbIndexArgs.js",
    "scripts-dist/IdxDbSvc.js",
    "scripts-dist/Misc.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3kBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Represents the arguments required for creating an index on a database table/store.\r\n */\r\nvar CreateDbIndexArgs = /** @class */ (function () {\r\n    /**\r\n     * Constructor.\r\n     * @param indexName Name of the index.\r\n     * @param keyPath Single field name or array of field names the index applies to.\r\n     * @param optionalParameters Optional parameters for the index.\r\n     */\r\n    function CreateDbIndexArgs(indexName, keyPath, optionalParameters) {\r\n        this.IndexName = indexName;\r\n        this.KeyPath = keyPath;\r\n        this.OptionalParameters = optionalParameters;\r\n    }\r\n    return CreateDbIndexArgs;\r\n}());\r\nexports.CreateDbIndexArgs = CreateDbIndexArgs;\r\n//# sourceMappingURL=CreateDbIndexArgs.js.map",
    "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar CreateDbIndexArgs_1 = require(\"./CreateDbIndexArgs\");\r\nvar Misc_1 = require(\"./Misc\");\r\nvar Misc_2 = require(\"./Misc\");\r\nvar Misc_3 = require(\"./Misc\");\r\nvar Misc_4 = require(\"./Misc\");\r\nvar Misc_5 = require(\"./Misc\");\r\nvar Misc_6 = require(\"./Misc\");\r\n/** IndexedDB Service */\r\nvar IdxDbSvc = /** @class */ (function () {\r\n    function IdxDbSvc(idxDbEnv) {\r\n        this.AddIsModifiedColumn = function (indexArray) {\r\n            indexArray.push(new CreateDbIndexArgs_1.CreateDbIndexArgs(\"IsModified\", \"IsModified\", { unique: false, multiEntry: false }));\r\n        };\r\n        this.IdxDbEnv = idxDbEnv;\r\n    }\r\n    IdxDbSvc.prototype.CreateDb = function (dbName, dbVersion, tableDefs) {\r\n        var self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var dbOpenRequest = self.IdxDbEnv.open(dbName, dbVersion);\r\n            dbOpenRequest.onupgradeneeded = function (event) {\r\n                //console.log(\"onupgradeneeded\");\r\n                self.OpenDbRequestStatus = \"upgrading\";\r\n                //deferred.notify(\"onupgradeneeded started\");\r\n                var db = dbOpenRequest.result;\r\n                db.onerror = function (event) {\r\n                    reject(Error(\"Error opening database \"));\r\n                };\r\n                db.onabort = function (event) {\r\n                    reject(\"Database opening aborted\");\r\n                };\r\n                // Create a store (table) for each table definition provided\r\n                tableDefs.forEach(function (tblDef) {\r\n                    //deferred.notify(\"Creating store \" + tblDef.TableName);\r\n                    self.BuildStore(db, tblDef.TableName, tblDef.ColNames, tblDef.PkColName, tblDef.AddIsModifiedCol);\r\n                    //deferred.notify(\"Created store \" + tblDef.TableName);\r\n                });\r\n                self.OpenDbRequestStatus = \"ok\";\r\n                //deferred.notify(\"dbOpenRequest.onupgradeneeded completed\");\r\n                //dbOpenRequest.result.close();\r\n                event.target.result.close();\r\n                resolve(true);\r\n            };\r\n            dbOpenRequest.onsuccess = function (event) {\r\n                if (self.OpenDbRequestStatus == \"ok\") {\r\n                    //deferred.notify(\"dbOpenRequest.onsuccess - ok\");\r\n                    //dbOpenRequest.result.close();\r\n                    event.target.result.close();\r\n                    resolve(true);\r\n                }\r\n                else {\r\n                    //deferred.notify(\"dbOpenRequest.onsuccess - upgrading\");\r\n                }\r\n            };\r\n            dbOpenRequest.onerror = function (event) {\r\n                reject(\"dbOpenRequest.onerror \" + event);\r\n            };\r\n            dbOpenRequest.onblocked = function (event) {\r\n                reject(\"dbOpenRequest.onblocked \" + event);\r\n            };\r\n        });\r\n    };\r\n    IdxDbSvc.prototype.GetStoreNames = function (dbName, dbVersion) {\r\n        var self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var dbOpenRequest = self.IdxDbEnv.open(dbName, dbVersion);\r\n            dbOpenRequest.onsuccess = function (ev /*Event*/) {\r\n                var db = ev.target.result;\r\n                resolve(db.objectStoreNames);\r\n                //dbOpenRequest.result.close();\r\n                ev.target.result.close();\r\n            };\r\n            dbOpenRequest.onerror = function (event) {\r\n                reject(Error(\"Error opening database\"));\r\n            };\r\n            dbOpenRequest.onblocked = function (event) {\r\n                reject(Error(\"Database opening blocked\"));\r\n            };\r\n        });\r\n    };\r\n    IdxDbSvc.prototype.DeleteDb = function (dbName) {\r\n        var self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var dbDeleteRequest = self.IdxDbEnv.deleteDatabase(dbName);\r\n            dbDeleteRequest.onerror = function (event) {\r\n                reject(Error(event.type));\r\n            };\r\n            dbDeleteRequest.onblocked = function (event) {\r\n                reject(Error(event.type));\r\n                event.target.result.close();\r\n                console.error(\"blocked\");\r\n            };\r\n            dbDeleteRequest.onupgradeneeded = function (event) {\r\n                reject(Error(event.type));\r\n            };\r\n            dbDeleteRequest.onsuccess = function (event) {\r\n                resolve(true);\r\n            };\r\n        });\r\n    };\r\n    IdxDbSvc.prototype.BuildStore = function (db, tblName, colNames, pkColName, addIsModifiedCol) {\r\n        if (!colNames || !colNames.length || colNames[0] == null) {\r\n            alert(\"No column data found for table \" + tblName);\r\n            //deferred.notify(\"No column data found for table \" + tblName);\r\n            return;\r\n        }\r\n        var self = this;\r\n        var indexesToCreate = [];\r\n        var isPkCol = false;\r\n        var createStoreOptions = {\r\n            keyPath: \"\",\r\n            autoIncrement: false\r\n        };\r\n        colNames.forEach(function (colName) {\r\n            if (colName === pkColName) {\r\n                isPkCol = true;\r\n            }\r\n            else {\r\n                isPkCol = false;\r\n            }\r\n            if (isPkCol) {\r\n                // Only create indexes for PK columns\r\n                indexesToCreate.push(new CreateDbIndexArgs_1.CreateDbIndexArgs(colName, colName, { unique: isPkCol, multiEntry: false }));\r\n            }\r\n            if (colName === pkColName) {\r\n                createStoreOptions.keyPath = colName;\r\n            }\r\n            createStoreOptions.autoIncrement = false;\r\n        });\r\n        if (addIsModifiedCol) {\r\n            self.AddIsModifiedColumn(indexesToCreate);\r\n        }\r\n        var store = db.createObjectStore(tblName, createStoreOptions);\r\n        indexesToCreate.forEach(function (dbIdxArgs) {\r\n            store.createIndex(dbIdxArgs.IndexName, dbIdxArgs.KeyPath, dbIdxArgs.OptionalParameters);\r\n        });\r\n    };\r\n    /**\r\n     * Searches for records.\r\n     * @param dbName The name of the database containing dbTableName.\r\n     * @param dbTableName The name of the table to search in.\r\n     * @param filterFn Optional filter function.\r\n     * @param transformFn Optional transformation function.\r\n     * @param orderBy Optional ordering function, field name or array of field names.\r\n     * @param returnFirstItemOnly Optional flag stating if only the first matching item should be returned.\r\n     */\r\n    IdxDbSvc.prototype.Query = function (dbName, dbTableName, filterFn, transformFn, orderBy, returnFirstItemOnly) {\r\n        var self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var callBackFunction = function (resultItems, errorMsg) {\r\n                if (!Misc_1.StrIsNullOrEmpty(errorMsg)) {\r\n                    reject(errorMsg);\r\n                    return;\r\n                }\r\n                // filterFn should be something like\r\n                // function (elementOfArray[, indexInArray]) { return elementOfArray.pr_Deleted == \"False\"; })\r\n                // transformFn should be something like\r\n                // function (valueOfElement) { return new Genus.PriceMatrixRule(valueOfElement); }\r\n                // Apply filter\r\n                if (typeof filterFn === \"function\") {\r\n                    resultItems = Misc_2.Grep(resultItems, filterFn);\r\n                }\r\n                // Apply transform to each element\r\n                if (typeof transformFn === \"function\") {\r\n                    var transformed;\r\n                    resultItems.forEach(function (valueOfElement /*: any*/, indexInArray) {\r\n                        transformed = transformFn.call(null, valueOfElement);\r\n                        resultItems[indexInArray] = transformed;\r\n                    });\r\n                }\r\n                // Sort\r\n                if (orderBy != null) {\r\n                    self.SortResultItems(resultItems, orderBy);\r\n                }\r\n                if (returnFirstItemOnly) {\r\n                    // Return just the first result item\r\n                    var first = resultItems[0];\r\n                    resolve(first);\r\n                }\r\n                else {\r\n                    resolve(resultItems);\r\n                }\r\n            };\r\n            var openDbRequest = self.IdxDbEnv.open(dbName);\r\n            openDbRequest.onsuccess = function (event) {\r\n                try {\r\n                    var db = event.target.result;\r\n                    var trans = db.transaction(dbTableName, \"readonly\");\r\n                    //if (trans) {\r\n                    trans.oncomplete = function () {\r\n                        db.close();\r\n                    };\r\n                    trans.onabort = function (evt /*Event*/) {\r\n                        var storeName = \"\", keyPath = \"\", error = \"\";\r\n                        //try {\r\n                        if (evt && evt.target) {\r\n                            if (evt.target.source) {\r\n                                storeName = evt.target.source.name;\r\n                                keyPath = evt.target.source.keyPath;\r\n                            }\r\n                            error = evt.target.error;\r\n                        }\r\n                        //} catch (e) {\r\n                        //}\r\n                        console.error(\"DbQuerySvc.Query transaction abort at \" + storeName + \".\" + keyPath + \": \" + error);\r\n                        db.close();\r\n                    };\r\n                    trans.onerror = function (evt /*Event*/) {\r\n                        var storeName = \"\", keyPath = \"\", error = \"\";\r\n                        //try {\r\n                        if (evt && evt.target) {\r\n                            if (evt.target.source) {\r\n                                storeName = evt.target.source.name;\r\n                                keyPath = evt.target.source.keyPath;\r\n                            }\r\n                            error = evt.target.error;\r\n                        }\r\n                        //} catch (e) {\r\n                        //}\r\n                        console.error(\"DbQuerySvc.Query transaction error at \" + storeName + \".\" + keyPath + \": \" + error);\r\n                        db.close();\r\n                    };\r\n                    var objectStore = trans.objectStore(dbTableName);\r\n                    var index = null;\r\n                    //if (indexName) {\r\n                    //    try {\r\n                    //        index = objectStore.index(indexName);\r\n                    //    }\r\n                    //    catch (e) {\r\n                    //    }\r\n                    //}\r\n                    var range = null;\r\n                    //if (keyRange) {\r\n                    //    try {\r\n                    //        range = IDBKeyRange.only(keyRange);\r\n                    //    } catch (e) {\r\n                    //    }\r\n                    //}\r\n                    //var cursorRequest: IDBRequest;\r\n                    //if (index && range) {\r\n                    //    cursorRequest = index.openCursor(range);\r\n                    //}\r\n                    //else if (index) {\r\n                    //    cursorRequest = index.openCursor();\r\n                    //}\r\n                    //else if (range) {\r\n                    //    cursorRequest = objectStore.openCursor(range);\r\n                    //}\r\n                    //else {\r\n                    //    cursorRequest = objectStore.openCursor();\r\n                    //}\r\n                    var cursorRequest = objectStore.openCursor();\r\n                    var results = [];\r\n                    cursorRequest.onsuccess = function (evt /*Event*/) {\r\n                        //var cursor = cursorRequest.result;\r\n                        var cursor /*: IDBCursor*/ = evt.target.result;\r\n                        if (cursor) {\r\n                            results.push(cursor.value);\r\n                            cursor.continue();\r\n                        }\r\n                        else if (typeof callBackFunction === \"function\") {\r\n                            callBackFunction.call(null, results /*, callBackArgs*/);\r\n                            trans.db.close();\r\n                        }\r\n                    };\r\n                    //}\r\n                }\r\n                catch (e) {\r\n                    console.error(dbTableName + \" table; \" + e.name + \"; \" + e.message);\r\n                    if (typeof callBackFunction === \"function\") {\r\n                        callBackFunction.call(null, null, e.name /*, callBackArgs*/);\r\n                        //dbOpenRequest.result.close();\r\n                    }\r\n                }\r\n            };\r\n            openDbRequest.onblocked = function (evt /*: Event*/) {\r\n                console.error(evt);\r\n            };\r\n            openDbRequest.onerror = function (evt /*: Event*/) {\r\n                console.error(evt);\r\n            };\r\n        });\r\n    };\r\n    IdxDbSvc.prototype.SortResultItems = function (resultIems, orderBy) {\r\n        // Sort\r\n        if (orderBy != null) {\r\n            if (typeof orderBy === \"function\") {\r\n                resultIems.sort(orderBy);\r\n            }\r\n            else if (typeof orderBy === \"string\") {\r\n                var fnSort = function (item1, item2) {\r\n                    return Misc_4.SortByStringField(orderBy, item1, item2);\r\n                };\r\n                resultIems.sort(fnSort);\r\n            }\r\n            else if (Misc_5.IsArray(orderBy)) {\r\n                resultIems.sort(Misc_3.SortByMany(orderBy));\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Saves data to the given object store.\r\n     * @param {string} dbName The IndexedDB database name.\r\n     * @param {string} dbTable The IndexedDB store/table name.\r\n     * @param {object|array} dbData The single item or the array of items to save.\r\n     * @returns {Promise} Returns a Promise that is resolved when the async store operation completes.\r\n     */\r\n    IdxDbSvc.prototype.Store = function (dbName, dbTable, dbData) {\r\n        var self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var openDbRequest = self.IdxDbEnv.open(dbName);\r\n            openDbRequest.onsuccess = function (evt) {\r\n                try {\r\n                    var db = evt.target.result;\r\n                    var tx = db.transaction(dbTable, \"readwrite\");\r\n                    var store = tx.objectStore(dbTable);\r\n                    // Check for array of items to store\r\n                    if (Misc_5.IsArray(dbData)) {\r\n                        // Array of items to store\r\n                        dbData.forEach(function (dataItem) {\r\n                            try {\r\n                                // Use put versus add to always write, even if exists\r\n                                //console.log(\"Putting item index \" + idx + \" into \" + dbTable + \"...\");\r\n                                store.put(dataItem);\r\n                            }\r\n                            catch (e) {\r\n                                console.error(\"Error putting data for \" + dbTable + \" - \" + e);\r\n                            }\r\n                        });\r\n                    }\r\n                    else {\r\n                        // Single item to store\r\n                        // Use put versus add to always write, even if exists\r\n                        store.put(dbData);\r\n                    }\r\n                    tx.oncomplete = function (evt) {\r\n                        resolve(); // Signal success\r\n                    };\r\n                    tx.onerror = function (evt) {\r\n                        console.error(evt);\r\n                        console.error(dbTable);\r\n                        var storeName = \"\", keyPath = \"\", error = \"\";\r\n                        try {\r\n                            if (evt && evt.target) {\r\n                                if (evt.target.source) {\r\n                                    storeName = evt.target.source.name;\r\n                                    keyPath = evt.target.source.keyPath;\r\n                                }\r\n                                error = evt.target.error;\r\n                            }\r\n                        }\r\n                        catch (e) {\r\n                        }\r\n                        console.error(\"DbQuerySvc.Store transaction abort at \" + storeName + \".\" + keyPath + \": \" + error);\r\n                        alert(\"Tx error in Store for table \" + dbTable + \" \" + error); //Temporary alert until sort out what to do with error here\r\n                        reject(\"Store tx error\"); // Signal error\r\n                    };\r\n                    tx.onabort = function (evt) {\r\n                        var errorName = \"\";\r\n                        try {\r\n                            if (evt && evt.target) {\r\n                                errorName = evt.target.error;\r\n                            }\r\n                        }\r\n                        catch (e) {\r\n                        }\r\n                        console.error(evt);\r\n                        console.error(dbTable);\r\n                        alert(\"Tx aborted in Store for table \" + dbTable + \" \" + errorName); //Temporary alert until sort out what to do with error here\r\n                        reject(\"Store tx aborted\"); // Signal error\r\n                    };\r\n                }\r\n                catch (e) {\r\n                    console.error(e);\r\n                    console.error(dbTable);\r\n                    alert(\"Error in Store\"); //Temporary alert until sort out what to do with error here\r\n                    reject(\"Store db open exception\"); // Signal error\r\n                }\r\n            };\r\n            openDbRequest.onblocked = function (evt) {\r\n                console.error(evt);\r\n                alert(\"Error in Load onblocked\"); //Temporary alert until sort out what to do with error here    \r\n                reject(\"Store db open onblocked\"); // Signal error\r\n            };\r\n            openDbRequest.onerror = function (evt) {\r\n                console.error(evt);\r\n                alert(\"Error in Load request onerror\"); //Temporary alert until sort out what to do with error here\r\n                reject(\"Store db open onerror\"); // Signal error\r\n            };\r\n        });\r\n    };\r\n    /**\r\n     * Deletes from given store the rows whose primary-key index value matches one of the specified values. Returns a Promise which handles the async operation.\r\n     * @param {string} dbName The IndexedDB database name.\r\n     * @param {string} dbTable The IndexedDB store/table name.\r\n     * @param {any|array<any>} primaryKeyVals A single, or array of, primary key values identifying the rows to delete.\r\n     * @returns {promise} Promise that is resolved when the async store operation completes.\r\n     */\r\n    IdxDbSvc.prototype.Delete = function (dbName, dbTable, /*indexName,*/ primaryKeyVals) {\r\n        return new Promise(function (resolve, reject) {\r\n            var openDbRequest = window.indexedDB.open(dbName);\r\n            openDbRequest.onsuccess = function (evt) {\r\n                try {\r\n                    var db = evt.target.result;\r\n                    var tx = db.transaction(dbTable, \"readwrite\");\r\n                    var store = tx.objectStore(dbTable);\r\n                    //var index = store.index(indexName);\r\n                    //var delReq;\r\n                    if (!Misc_5.IsArray(primaryKeyVals)) {\r\n                        // Make array of 1 item\r\n                        primaryKeyVals = [primaryKeyVals];\r\n                    }\r\n                    // Delete the row for each key\r\n                    //$.each(primaryKeyVals, function (idx, keyVal) {\r\n                    //    store.delete(keyVal);\r\n                    //});\r\n                    for (var keyVal in primaryKeyVals) {\r\n                        store.delete(keyVal);\r\n                    }\r\n                    tx.oncomplete = function (evt) {\r\n                        resolve(); // Signal success\r\n                    };\r\n                    tx.onerror = function (evt) {\r\n                        console.error(evt);\r\n                        alert(\"Error in Delete onerror\");\r\n                        reject(Error(\"Delete tx error\")); // Signal error\r\n                    };\r\n                    tx.onabort = function (evt) {\r\n                        console.error(evt);\r\n                        alert(\"Error in Delete abort\");\r\n                        reject(Error(\"Delete tx aborted\")); // Signal error\r\n                    };\r\n                }\r\n                catch (e) {\r\n                    console.error(\"Delete - error deleting from \" + dbTable + \" - \" + e);\r\n                    alert(\"Error in Delete for table \" + dbTable);\r\n                    reject(e);\r\n                }\r\n            };\r\n            openDbRequest.onblocked = function (evt) {\r\n                console.error(evt);\r\n                alert(\"Error in Delete, openDbRequest.onblocked \" + evt); //Temporary alert until sort out what to do with error here\r\n                reject(Error(\"Delete db open onblocked\")); // Signal error\r\n            };\r\n            openDbRequest.onerror = function (evt) {\r\n                console.error(evt);\r\n                alert(\"Error in Delete, openDbRequest.onerror \" + evt); //Temporary alert until sort out what to do with error here\r\n                reject(Error(\"Delete db open onerror\")); // Signal error\r\n            };\r\n        });\r\n    };\r\n    /**\r\n     * Updates an existing record or records.\r\n     * @param {string} dbName The IndexedDB database name.\r\n     * @param {string} dbTableName The IndexedDB store/table name.\r\n     * @param {string|array<string>|function} primaryKeyValsOrFilterFn A single, or array of, primary key values identifying the rows to update, or a function describing which rows to update.\r\n     * @param {object} updateObj An object describing the fields and values to update.\r\n     * @returns {promise} Returns a promise indicating the number of rows updates, that is resolved when the async store operation completes.\r\n    */\r\n    IdxDbSvc.prototype.Update = function (dbName, dbTableName, primaryKeyValsOrFilterFn, updateObj) {\r\n        var self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            if (typeof primaryKeyValsOrFilterFn === \"function\") {\r\n                ProceedWithUpdate(primaryKeyValsOrFilterFn);\r\n            }\r\n            else {\r\n                self.GetPrimaryKeyName(dbName, dbTableName)\r\n                    .then(function (pkName) {\r\n                    if (typeof primaryKeyValsOrFilterFn === \"string\") {\r\n                        // Make array of single pk value\r\n                        primaryKeyValsOrFilterFn = [primaryKeyValsOrFilterFn];\r\n                    }\r\n                    // Build filter function\r\n                    var filterFn = function (dbItem) {\r\n                        return Misc_6.StringArrayContains(primaryKeyValsOrFilterFn, dbItem[pkName]);\r\n                    };\r\n                    ProceedWithUpdate(filterFn);\r\n                })\r\n                    .catch(function (failReason) {\r\n                    reject(\"Update failed for \" + dbTableName + \"; \" + failReason);\r\n                });\r\n            }\r\n            /**\r\n             * Continues the update operation.\r\n             * @param {any} filterFn A function describing which rows to update.\r\n             */\r\n            function ProceedWithUpdate(filterFn) {\r\n                // Find the records to update\r\n                self.Query(dbName, dbTableName, filterFn)\r\n                    .then(function (itemsToUpdate) {\r\n                    if (itemsToUpdate && itemsToUpdate.length > 0) {\r\n                        // Update the matching records\r\n                        $.each(itemsToUpdate, function (idx, item) {\r\n                            itemsToUpdate[idx] = $.extend(itemsToUpdate[idx], updateObj);\r\n                        });\r\n                        // Store in db again\r\n                        self.Store(dbName, dbTableName, itemsToUpdate)\r\n                            .then(function () {\r\n                            // Indicate success and number of rows updated\r\n                            resolve(itemsToUpdate.length);\r\n                        })\r\n                            .catch(function (failReason) {\r\n                            reject(\"Update failed for \" + dbTableName + \"; \" + failReason);\r\n                        });\r\n                    }\r\n                    else {\r\n                        // Indicate success but zero rows updated\r\n                        resolve(0);\r\n                    }\r\n                })\r\n                    .catch(function (failReason) {\r\n                    reject(\"Update failed for \" + dbTableName + \"; \" + failReason);\r\n                });\r\n            }\r\n        });\r\n    };\r\n    IdxDbSvc.prototype.GetPrimaryKeyName = function (dbName, dbTableName) {\r\n        return new Promise(function (resolve, reject) {\r\n            var openDbRequest = indexedDB.open(dbName);\r\n            openDbRequest.onsuccess = function (event) {\r\n                try {\r\n                    var db = event.target.result;\r\n                    var trans = db.transaction(dbTableName, \"readonly\");\r\n                    var primaryKey;\r\n                    if (trans) {\r\n                        trans.oncomplete = function () {\r\n                            db.close();\r\n                            if (primaryKey) {\r\n                                resolve(primaryKey);\r\n                            }\r\n                            else {\r\n                                reject(Error(\"PK not found for \" + dbTableName));\r\n                            }\r\n                        };\r\n                        trans.onabort = function (evt) {\r\n                            var storeName = \"\", keyPath = \"\", error = \"\";\r\n                            if (evt && evt.target) {\r\n                                if (evt.target.source) {\r\n                                    storeName = evt.target.source.name;\r\n                                    keyPath = evt.target.source.keyPath;\r\n                                }\r\n                                error = evt.target.error;\r\n                            }\r\n                            var msg = \"DbQuerySvc.GetPrimaryKeyName transaction abort at \" + storeName + \".\" + keyPath + \": \" + error;\r\n                            console.error(msg);\r\n                            db.close();\r\n                            reject(Error(\"onabort \" + msg));\r\n                        };\r\n                        trans.onerror = function (evt) {\r\n                            var storeName = \"\", keyPath = \"\", error = \"\";\r\n                            if (evt && evt.target) {\r\n                                if (evt.target.source) {\r\n                                    storeName = evt.target.source.name;\r\n                                    keyPath = evt.target.source.keyPath;\r\n                                }\r\n                                error = evt.target.error;\r\n                            }\r\n                            db.close();\r\n                            var msg = \"DbQuerySvc.GetPrimaryKeyName transaction error at \" + storeName + \".\" + keyPath + \": \" + error;\r\n                            console.error(msg);\r\n                            reject(Error(\"onerror \" + msg));\r\n                        };\r\n                        var objectStore /*: IDBObjectStore*/ = trans.objectStore(dbTableName);\r\n                        if (objectStore.indexNames != null) {\r\n                            primaryKey = objectStore.indexNames[0];\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    console.error(dbTableName + \" table; \" + e.name + \"; \" + e.message);\r\n                    reject(Error(\"Error getting pk names for \" + dbTableName + \"; \" + e.name + \"; \" + e.message));\r\n                }\r\n            };\r\n            openDbRequest.onblocked = function (evt /*: Event*/) {\r\n                console.error(evt);\r\n                reject(Error(\"onblocked\"));\r\n            };\r\n            openDbRequest.onerror = function (evt /*: Event*/) {\r\n                console.error(evt);\r\n                reject(Error(\"onerror\"));\r\n            };\r\n        });\r\n    };\r\n    return IdxDbSvc;\r\n}());\r\nexports.IdxDbSvc = IdxDbSvc;\r\n//# sourceMappingURL=IdxDbSvc.js.map",
    "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction StrIsNullOrEmpty(str) {\r\n    if (str == null || str.length === 0) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.StrIsNullOrEmpty = StrIsNullOrEmpty;\r\nfunction Grep(items, filterFn) {\r\n    if (items == null || items.length == 0) {\r\n        return items;\r\n    }\r\n    var matches = [];\r\n    items.forEach(function (item) {\r\n        if (filterFn(item)) {\r\n            matches.push(item);\r\n        }\r\n    });\r\n    return matches;\r\n}\r\nexports.Grep = Grep;\r\nfunction ObjectToSortable(obj) {\r\n    if (obj !== null && obj !== undefined && typeof obj === \"string\") {\r\n        return obj.toLowerCase();\r\n    }\r\n    return obj;\r\n}\r\nexports.ObjectToSortable = ObjectToSortable;\r\n/**\r\nPass this to array.sort(fn). Sorts an array by many fields and each in either asc or desc order.\r\n@param {[]} fields An array of field string names and/or sub-arrays of names, direction flag, and conversion functions.\r\n@returns {Function} Returns a function that can be consumed by array.sort(fn).\r\n*/\r\nfunction SortByMany(fields) {\r\n    var n_fields = fields.length;\r\n    return function (a, b) {\r\n        var fieldValueA, fieldValueB, field, key, primer, reverse, result = 0;\r\n        for (var i = 0, l = n_fields; i < l; i++) {\r\n            result = 0;\r\n            field = fields[i];\r\n            if (typeof field === \"string\") {\r\n                key = field;\r\n                reverse = 1;\r\n            }\r\n            else {\r\n                key = field[0];\r\n                reverse = field[1] ? -1 : 1;\r\n            }\r\n            fieldValueA = a[key];\r\n            fieldValueB = b[key];\r\n            if (typeof field[2] === \"function\") {\r\n                fieldValueA = field[2].call(null, fieldValueA);\r\n                fieldValueB = field[2].call(null, fieldValueB);\r\n            }\r\n            if (fieldValueA < fieldValueB)\r\n                result = reverse * -1;\r\n            if (fieldValueA > fieldValueB)\r\n                result = reverse * 1;\r\n            if (result !== 0)\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n}\r\nexports.SortByMany = SortByMany;\r\nfunction SortByStringField(fieldName, item1, item2) {\r\n    var item1Field = ObjectToSortable(item1[fieldName]);\r\n    var item2Field = ObjectToSortable(item2[fieldName]);\r\n    if (item1Field > item2Field) {\r\n        return 1;\r\n    }\r\n    if (item2Field > item1Field) {\r\n        return -1;\r\n    }\r\n    return 0; // Same    \r\n}\r\nexports.SortByStringField = SortByStringField;\r\nfunction IsArray(obj) {\r\n    if (obj && typeof obj === \"object\" && obj instanceof Array) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.IsArray = IsArray;\r\n/**\r\n  * Determines if 2 strings are equal.\r\n  * @param {string} str1 The first string.\r\n  * @param {string} str2 The second string.\r\n  * @param {boolean} [cs] Optional flag indicating whether or not to do a case-sensitive comparison. Default is false (case-insensitive).\r\n  * @param {boolean} [nullEqualsEmpty] Optional flag indicating whether or not to consider null and zero-length strings to be equal. Default is false (not equal).\r\n  * @returns {boolean} True/false indicating if equal or not.\r\n */\r\nfunction StrEq(str1, str2, cs, nullEqualsEmpty) {\r\n    if (str1 == null && str2 == null) {\r\n        // Both are null - match\r\n        return true;\r\n    }\r\n    if (nullEqualsEmpty === true && (str1 == null || str1 == \"\") && (str2 == null || str2 == \"\")) {\r\n        // Null and empty considered equal, and both are null or empty\r\n        return true;\r\n    }\r\n    // One is null, the other isn't - no match\r\n    if (str1 == null || str2 == null) {\r\n        return false;\r\n    }\r\n    // Case-sensitive comparison\r\n    if (cs === true) {\r\n        return str1.toString() == str2.toString();\r\n    }\r\n    // Case-insensitive comparison\r\n    return str1.toString().toLowerCase() == str2.toString().toLowerCase();\r\n}\r\nexports.StrEq = StrEq;\r\n/**\r\n * Determines if a string array contains a particular string.\r\n * @param {Array<string>} arr Array of strings to search in.\r\n * @param {string} str The string to search for.\r\n * @param {boolean} cs Case-sensitive search. Defaults to false (case-insensitive) if not specified.\r\n */\r\nfunction StringArrayContains(arr, str, cs) {\r\n    if (arr != null) {\r\n        for (var idx = 0; idx < arr.length; idx++) {\r\n            if (StrEq(arr[idx], str, cs)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.StringArrayContains = StringArrayContains;\r\n//# sourceMappingURL=Misc.js.map"
  ]
}